{"/about/":{"data":{"":" ‚ÑπÔ∏è In this site, you will find essential resources to master the exciting world of object-oriented programming. This documentation platform emerged in 2023 as a response to the growing need to centralize all the educational resources produced by the university. Our primary goal was to create a unified and easily accessible hub for students to access a wealth of educational content and concepts. Why We Created This Site:\nThis documentation platform emerged from our commitment to enhancing the teaching and learning experience of our Object-Oriented Programming course. We wanted to explore new ways of delivering the course content by leveraging modern technology and platforms. Our goal is to make learning about object-oriented programming more accessible and engaging for everyone.\nWhat are our objectives:\nCreate digital resources that support learning-teaching activities within the object-oriented programming courses at Universidad Nacional de Colombia. Encourage their own digital resources and integrate them with our work. Promote student-centered learning methods, including active learning, flipped classroom, and problem-based learning. What we offer:\nFundamental Concepts: Learn the pillars of object-oriented programming, from classes and objects to encapsulation and inheritance.\nPractical Examples: Dive into code examples with real-world scenarios to understand how to apply these concepts to your own projects.\nProgramming Languages: Explore examples in different languages, allowing you to apply these concepts in the programming language that suits you best.\nComprehensive Documentation: Navigate through detailed and organized documentation covering every aspect of object-oriented programming.\nFrequently Asked Questions: Find answers to common questions that arise when exploring this topic.\nStart your learning journey today and discover how object-oriented programming can revolutionize your approach to software development.\nWe are here to assist you every step of the way!\nStart here with contents Practice "},"title":"About course"},"/about/profesores/":{"data":{"":"Jairo Hern√°n Aponte, PhD site\nAssociate-professor: Systems and Industrial Engineering Department | Engineering Faculty | Universidad Nacional de Colombia Jean Pierre Charalambos, PhD\nAssociate-professor: Systems and Industrial Engineering Department | Engineering Faculty | Universidad Nacional de Colombia "},"title":"Involved teachers"},"/docs/":{"data":{"":" ‚ÑπÔ∏è Welcome to our comprehensive Object-Oriented Programming (OOP) Course! In this course, you‚Äôll not only master the fundamental skills of OOP but also explore various methodologies to effectively apply these concepts in real-world problem-solving. Gain hands-on experience with practical coding exercises, in-depth theoretical explanations, and industry-focused interview preparation. ","what-is-object-oriented-programming-oop#What is Object-Oriented Programming (OOP)?":"Object-Oriented Programming (OOP) is a programming model that arranges software design around data, or objects, rather than functions and logic. In this approach, an object is defined as a data field with unique attributes (properties) and behavior (methods).\nOOP focuses on the objects that developers want to manipulate, rather than the logic required to manipulate them. This approach is particularly useful for large, complex programs that require constant updates or maintenance. Areas of application include manufacturing and design programs, as well as mobile applications. For example, OOP can be applied to develop manufacturing system simulation software.","why-is-object-oriented-programming-important#Why is Object-Oriented Programming important?":"Object-Oriented Programming (OOP) is important for several reasons:\nReal-world modeling: OOP provides a programming model that reflects how we think about the real world. Objects and classes in OOP can represent real-world entities and concepts naturally, making it easier to understand the code and its relationship to the problem it is solving.\nEncapsulation and information hiding: OOP allows data and functions to be encapsulated within objects, meaning that the internal implementation of an object can be hidden from the outside. This promotes modularity and reduces complexity by providing a clear and consistent interface for interacting with objects.\nFacilitates collaboration: OOP facilitates collaboration among development teams by providing a clear and consistent structure for software design and implementation. Well-defined objects and clear interface contracts allow teams to work independently on different parts of the code.\nFacilitates code maintenance: OOP makes it easier to make changes to the code, as objects and classes are designed to be modular and cohesive. This makes it easier to add new features, fix bugs, and perform updates to existing software.\nScalability: OOP provides a scalable approach to software development, making it easier to manage and extend large and complex projects. It allows for the creation of modular components that can be developed and tested independently.\nOverall, OOP enhances code organization, promotes code reusability, improves code reliability, and simplifies software development. It is widely used in various domains, including software engineering, game development, web development, and more.\nTo truly harness the power of OOP, it‚Äôs essential to understand its foundational principles. We invite you to begin your journey by exploring the basic concepts and basic principles of OOP:\nBasic Concepts Core Principles "},"title":"Introduction"},"/docs/basic-concepts/":{"data":{"":"","#":" ‚ÑπÔ∏è Object-Oriented Programming (OOP) relies on fundamental concepts that are essential for building and managing software systems. Object-Oriented Programming (OOP) is built upon a foundation of core concepts that shape how software is designed, structured, and implemented. These fundamental ideas are essential for creating robust, maintainable, and scalable applications.\nWhen learning OOP, it‚Äôs crucial to have a strong understanding of the basic concepts that drive this programming paradigm. These include objects, classes, attributes, methods, and more. Each of these concepts plays a unique role in organizing and managing code effectively.\nTo guide your learning journey, we‚Äôll use a common example: a Bank Account. This example will help illustrate how these basic concepts come together to create a functional and cohesive system.\nReady to learn more? Now that you‚Äôve been introduced to the foundational ideas of OOP, it‚Äôs time to dive deeper into each concept. Mastering these basics will set the stage for building powerful applications that follow best practices in software design. Let‚Äôs start with a core concept, Classes.\nClass Object Attributes Methods "},"title":"Basic Concepts"},"/docs/basic-concepts/attributes/":{"data":{"":"","#":" ‚ÑπÔ∏è In object-oriented programming (OOP), an attribute (also known as a property or field) is a characteristic or property of an object. It represents the data that an object holds and defines its state. Attributes are defined within a class, and each object created from that class has its own unique values for those attributes. For example, in a BankAccount class, attributes might include the accountNumber, balance, and accountHolder.\nLet‚Äôs delve into the concept of attributes considering the BankAccount class. Each bank account object created from this class will have its own set of attributes:\nBank Account Example: Consider the BankAccount class. Each bank account object created from this class will have its own set of attributes:\n„Ö§„Ö§„Ö§„Ö§„Ö§BankAccount„Ö§„Ö§„Ö§„Ö§„Ö§ accountNumber: Int balance: Int accountHolder: String Suppose we create two BankAccount objects:\n„Ö§„Ö§„Ö§„Ö§„Ö§account1„Ö§„Ö§„Ö§„Ö§„Ö§ „Ö§„Ö§„Ö§„Ö§„Ö§account2„Ö§„Ö§„Ö§„Ö§„Ö§ accountNumber: 123456 balance: 500 accountHolder: John Doe accountNumber: 789012 balance: 1000 accountHolder: Jane Smith In this example, we see that although both account1 and account2 are instances of the BankAccount class, each object has its own unique attribute values.\nEach object of the BankAccount class shares the same attributes, but the values of these attributes differ from one object to another. This distinction between objects is a fundamental concept in object-oriented programming, where each object carries its own specific data while sharing the same structure and behavior as defined by the class. Understanding how attributes work helps in managing and manipulating objects effectively within a program."},"title":"Attributes"},"/docs/basic-concepts/class/":{"data":{"":"","#":" ‚ÑπÔ∏è A class is a user-defined data type. A class is a blueprint for creating objects that share common properties and behaviors. A class can be thought of as a blueprint that defines the structure of objects in a program. It‚Äôs like a mold from which individual objects are created, each with its own attributes and behaviors.\nLet‚Äôs consider the concept of a class using the example of a BankAccount.\nA class is like a blueprint or template for creating objects. In our example, the BankAccount class represents the blueprint for creating individual bank account objects.\nclassDiagram class BankAccount { Int accountNumber Int Balance String accountHolder deposit(amount) withdraw(amount) } classDiagram class BankAccount { Int accountNumber Int Balance String accountHolder deposit(amount) withdraw(amount) } „Ö§„Ö§„Ö§„Ö§„Ö§BankAccount„Ö§„Ö§„Ö§„Ö§„Ö§ accountNumber : Int balance : Int accountHolder : String deposit(amount) withdraw(amount) Attributes: Attributes are characteristics or properties that describe the objects created from the class. For instance, in the case of a BankAccount, attributes could include accountNumber, balance, and accountHolder. Methods: Methods are functions that define the behavior of the objects created from the class. In the context of a BankAccount, methods could include operations like deposit and withdraw, which specify how money can be added to or withdrawn from an account. This class blueprint defines the structure for creating BankAccount objects. Each object instantiated from this class inherits attributes such as accountNumber, balance and accountHolder. Additionally, the methods such as deposit() and withdraw(), enable the objects to perform operations like adding or withdrawing money."},"title":"Classes"},"/docs/basic-concepts/methods/":{"data":{"":"","#":" ‚ÑπÔ∏è In object-oriented programming, methods define the actions that an object can perform. They are functions within a class that describe the behaviors or operations of the objects created from the class. Methods are integral to how objects interact with each other and perform tasks. Let‚Äôs explore this concept using the BankAccount class example:\n„Ö§„Ö§„Ö§„Ö§„Ö§BankAccount„Ö§„Ö§„Ö§„Ö§„Ö§ deposit(amount) withdraw(amount) Bank Account Example: For instance, let‚Äôs use the BankAccount class to create two bank account objects:\n„Ö§„Ö§„Ö§„Ö§„Ö§account1„Ö§„Ö§„Ö§„Ö§„Ö§ „Ö§„Ö§„Ö§„Ö§„Ö§account2„Ö§„Ö§„Ö§„Ö§„Ö§ accountNumber: 123456 balance: 500 accountHolder: John Doe accountNumber: 789012 balance: 1000 accountHolder: Jane Smith deposit(amount) withdraw(amount) deposit(amount) withdraw(amount) Method Usage: account1 can use the deposit method to add funds and the withdraw method to withdraw funds. account2 has the same methods but can perform deposit and withdraw operations based on its own balance and account details. Each object has access to the same methods defined in the class, which enables them to perform similar actions, but the outcomes of these methods depend on the object‚Äôs specific attributes and current state.\nExplore the Core Principles chapter to learn more about how methods integrate with the core principles of OOP, including inheritance, polymorphism, abstraction, and encapsulation. "},"title":"Methods"},"/docs/basic-concepts/object/":{"data":{"":"","#":" ‚ÑπÔ∏è In object-oriented programming (OOP), an object is an instance of a class, encapsulating attributes and behaviors to model real-world entities. Remember that we have a class called BankAccount. This class represents a bank account, and it has methods to perform banking operations like depositing money and withdrawing money.\nIn our example, an object is an instance of the BankAccount class. Each individual bank account created from the BankAccount class is an object.\nThese objects, such as account 1 and account 2, inherit attributes and methods from the class, but hold their own unique data.\nAttributes: Each bank account object has its own set of attributes that describe its specific state. For instance, each bank account object might have attributes like accountNumber, balance, and accountHolder. Methods: Objects have access to the methods defined by their class. These methods define the behavior or actions that objects can perform. For example, each bank account object can use methods like deposit and withdraw to manage its funds. Bank Account Example: Suppose we create two bank account objects from the BankAccount class:\n„Ö§„Ö§„Ö§„Ö§„Ö§Account 1„Ö§„Ö§„Ö§„Ö§„Ö§ „Ö§„Ö§„Ö§„Ö§„Ö§Account 2„Ö§„Ö§„Ö§„Ö§„Ö§ accountNumber: 123456 balance: 500 accountHolder: John Doe accountNumber: 789012 balance: 1000 accountHolder: Jane Smith deposit(amount) withdraw(amount) deposit(amount) withdraw(amount) Each bank account object represents a distinct bank account with its own unique attributes and behaviors. For example, account 1 and account 2 have different accountNumbers, balances, and accountHolders. They can each independently use the deposit and withdraw methods to manage their funds."},"title":"Object"},"/docs/core-principles/":{"data":{"":"","basic-principles-of-object-oriented-programming-oop#Basic principles of Object-Oriented Programming (OOP):":" Encapsulation: Encapsulation is the process of hiding the internal details of an object and exposing only the necessary information or functionality. It helps in achieving data abstraction and provides better control over the data.\nAbstraction: Abstraction focuses on representing the essential features of an object, while hiding the unnecessary details. It helps in managing complexity and simplifies the development process.\nInheritance: Inheritance allows objects to inherit properties and behaviors from a parent class. It promotes code reusability and helps in creating a hierarchical structure of classes.\nPolymorphism: Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables the use of a single interface to represent different types of objects, providing flexibility and extensibility.\nThese principles form the foundation of OOP and are essential for building modular, maintainable, and scalable software systems.\nChoose the principle of your interest from the buttons below:\nEncapsulation Inheritance Polymorphism Abstraction "},"title":"Core Principles"},"/docs/core-principles/abstraction/":{"data":{"":"","#":" ‚ÑπÔ∏è Abstraction is a core principle of object-oriented programming (OOP) that focuses on hiding complex implementation details and exposing only the essential features of an object. By using abstraction, developers can simplify complex systems by breaking them down into more manageable parts. In OOP, Abstraction enables you to represent essential aspects of an object without exposing its internal workings. It allows for designing classes that can interact with other parts of the system while hiding unnecessary complexities.\nFor example, in a banking application, you might need to interact with bank accounts, but you don‚Äôt need to know the complex algorithms that calculate interest or handle transactions. Instead, you only care about the essential methods and attributes like deposit(), withdraw(), and balance.\nBank Account Example Let‚Äôs abstract the core functionality of a bank account by defining a BankAccount class that hides the internal logic while exposing essential methods for interacting with it.\nclassDiagram class BankAccount { - Int accountNumber - Int balance - String accountHolder + deposit(amount) + withdraw(amount) + getBalance() } Attributes (accountNumber, balance, and accountHolder) are private üîí These represent the internal data of the BankAccount. By keeping these attributes private, we ensure that they cannot be accessed or modified directly by external code. For example, without abstraction, an external user could directly modify attributes like balance to any value, even negative amounts.\nAbstraction protects this data, ensuring that changes are made through controlled methods like deposit(amount) and withdraw(amount).\nMethods like deposit(amount) and withdraw(amount) are public üîì These methods provide an interface to interact with the BankAccount object. Through abstraction, users can perform essential operations without needing to know how these methods are implemented internally.\nWhy Abstraction Matters? Separation of Concerns Abstraction ensures that each part of the system focuses on a specific task. The BankAccount class manages the account data internally, while external code only interacts with it through public methods. This separation makes the system easier to understand, maintain, and extend.\nSecurity By hiding the internal state of the object, we prevent unauthorized or unintended changes. For instance, without abstraction, a user could directly change the accountNumber of an account. Abstraction ensures that such sensitive data is protected, allowing only authorized interactions through the defined methods.\nSimplified Interface Users of the class only need to focus on what‚Äôs essential for them. A person using the BankAccount class doesn‚Äôt care about how the balance is stored in memory or how funds are transferred; they only care about interacting with the interface provided‚Äîdepositing, withdrawing, and checking the balance.\nThrough Abstraction, we define a simple interface for interacting with objects, hiding unnecessary details while maintaining control over how data is accessed and modified. This principle enhances security, improves code maintainability, and ensures a cleaner, more understandable interface.\n‚ÑπÔ∏è Next Step:\nNow that you‚Äôve seen how abstraction simplifies object interactions, explore Inheritance , which allows a class (called a child or subclass) to inherit properties and behaviors from another class (called a parent or superclass)."},"title":"Abstraction"},"/docs/core-principles/encapsulation/":{"data":{"":"","#":" ‚ÑπÔ∏è Encapsulation is a fundamental principle of object-oriented programming (OOP) that restricts direct access to some of an object‚Äôs components and keeps data safe within objects. It is about bundling the data (attributes) and the methods that operate on that data into a single unit or class, while controlling access to the data through well-defined interfaces. Encapsulation allows the internal state of an object be hidden from the outside world. External code cannot directly access or modify the attributes of an object; instead, interaction happens through public methods, which manage how data is accessed and changed. This principle protects the integrity of the object and enforces a controlled interaction.\nBank Account Example: To demonstrate this principle, let‚Äôs revisit the BankAccount class. We will use encapsulation to restrict direct access to the account attributes and allow interactions only through the deposit() and withdraw() methods:\nclassDiagram class BankAccount { - Int accountNumber - Int balance - String accountHolder + deposit(amount) + withdraw(amount) + getBalance() } The accountNumber, balance, and accountHolder are private üîí, meaning they cannot be accessed or modified directly from outside the class. The deposit(), withdraw(), and getBalance() methods are public üîì and allow controlled interaction with the BankAccount class. Encapsulation ensures that an object‚Äôs internal state is protected from unintended interference, making it easier to maintain and modify code. It also improves the security and robustness of a program.\nWhy Encapsulation Matters? Data Integrity By restricting direct access to attributes, encapsulation helps ensure that the internal state of an object remains consistent. You can‚Äôt set invalid or unsafe values on the balance directly; instead, it‚Äôs modified through controlled methods that validate input.\nModularity Encapsulation allows changes to the internal implementation of a class without affecting how other parts of the code interact with it. For example, you can change how getBalance() calculates the balance, and the external code won‚Äôt need to be updated.\nSecurity By keeping private attributes inaccessible from outside, encapsulation enhances security. For example, it prevents unauthorized or unintended modifications to critical data, like changing an account‚Äôs balance directly.\nEase of Maintenance Encapsulation makes the codebase easier to maintain. Changes to internal workings of the object can be made without breaking the rest of the system since the external interface remains the same.\n‚ÑπÔ∏è Next Step:\nNow that you‚Äôve mastered how encapsulation protects object data and provides controlled access, proceed to learn about Abstraction, which focuses on simplifying complex systems by hiding unnecessary details."},"title":"Encapsulation"},"/docs/core-principles/inheritance/":{"data":{"":"","#":" ‚ÑπÔ∏è Inheritance is a fundamental principle of object-oriented programming (OOP) that allows a class (called a child or subclass) to inherit properties and behaviors from another class (called a parent or superclass). This enables code reusability, as common attributes and methods can be defined in the parent class and inherited by its subclasses. Inheritance promotes the reusability of code by allowing classes to derive common characteristics from a base class. It enables the creation of hierarchical relationships between classes, where a child class can inherit and extend the functionality of its parent class. Subclasses can override or extend inherited methods, adding flexibility and specificity.\nBank Account Example: To illustrate Inheritance, let‚Äôs extend our BankAccount class to create specialized types of accounts. For instance, we can create a SavingsAccount class that inherits from BankAccount and adds a specific interest rate.\nclassDiagram class BankAccount { - Int accountNumber - Int balance - String accountHolder + deposit(amount) + withdraw(amount) + getBalance() } class SavingsAccount { - Float interestRate + applyInterest() } BankAccount \u003c|-- SavingsAccount BankAccount provides shared attributes like accountNumber, balance, and accountHolder, along with shared methods like deposit(), withdraw(), and getBalance(). SavingsAccount inherits all the properties and behaviors of BankAccount but adds its own interestRateüîí attribute and the applyInterest()üîì method. This example illustrates how Inheritance allows new classes to build on top of existing ones. The SavingsAccount class can leverage all the functionality of BankAccount while introducing its own features like calculating interest. By sharing common code between the parent and child classes, inheritance reduces redundancy and promotes a cleaner design.\nWhy Inheritance Matters? Code Reusability Inheritance helps avoid duplication by allowing multiple subclasses to inherit common functionality from a single parent class. This way, shared attributes and methods can be reused without having to rewrite them in each subclass.\nExtensibility Inheritance makes it easy to extend functionality. You can create new classes based on existing ones, introducing specialized behaviors while maintaining the foundational code from the parent class.\nMaintainability By organizing code into parent-child class relationships, Inheritance simplifies maintenance. Changes in the parent class automatically propagate to all subclasses, ensuring consistency across your application.\nHierarchical Organization Inheritance naturally supports the creation of a class hierarchy. This makes it easier to understand and structure complex systems, particularly when there are multiple related classes.\n‚ÑπÔ∏è Next Step:\nNow that you‚Äôve learned how Inheritance promotes code reusability and extensibility, the next step is to explore Polymorphism, which allows objects of different classes to be treated uniformly."},"title":"Inheritance"},"/docs/core-principles/polymorphism/":{"data":{"":"","#":" ‚ÑπÔ∏è Polymorphism is a fundamental principle in OOP that allows objects of different classes to be treated as objects of a common base class. It enables one interface to be used for different data types or classes, simplifying code and making it more flexible. Polymorphism allows for methods to behave differently based on the object that invokes them. It enables multiple classes to implement methods that share the same name but provide different functionalities depending on the specific class.\nFor example, a banking system might have different types of accounts such as SavingsAccount and CheckingAccount. Both types of accounts could share a common method like applyInterest() , but each would calculate interest in a different way.\nBank Account Example: Imagine we have a base class, BankAccount, and a subclass, SavingsAccount. The method applyInterest() behaves differently in the SavingsAccount class compared to a more generic method in BankAccount:\nclassDiagram class BankAccount { + deposit(amount) + withdraw(amount) + getBalance() } class SavingsAccount { + Float interestRate + applyInterest() + withdraw(amount) } BankAccount \u003c|-- SavingsAccount In the diagram:\nThe method withdraw(amount) is overridden in the SavingsAccount class to account for savings-specific rules (like a fee or limit). Methods within the same class that share the same name but have different parameters.\nThe method applyInterest() adds behavior specific to savings accounts, demonstrating method overloading because a subclass is providing specific implementation of a method already defined in its superclass.\nPolymorphism allows BankAccount and SavingsAccount to share similar methods, but execute them differently depending on the object‚Äôs type. For example, both classes have a withdraw(amount) method, but the behavior differs depending on whether the object is a BankAccount or a SavingsAccount.\nWhy Polymorphism Matters? Code Reusability Polymorphism allows a base class like BankAccount to define general behavior, while subclasses like SavingsAccount can build on and modify that behavior. This makes it easier to extend the system without rewriting code.\nMaintainability Polymorphism simplifies code maintenance. If you need to change the behavior of a method for a particular class, you can override it in the subclass, without altering the base class or other subclasses.\nDynamic Behavior At runtime, the system can decide which method to invoke depending on the object‚Äôs type, leading to more flexible and dynamic code.\n‚ÑπÔ∏è Next Step:\nNow that you‚Äôve mastered all four core principles of object-oriented programming (OOP), it‚Äôs time to explore the Methodologies section, where you can dive into different learning paths. These methodologies provide various ways to apply the OOP concepts you‚Äôve learned based on different teaching styles and use cases.\nQuiz Question 1: What is OOP?\nA programming paradigm\nA database model"},"title":"Polymorphism"},"/methodologies/":{"data":{"":"In the journey of learning object-oriented programming (OOP), different educators might employ various methodologies to convey the concepts effectively. Each approach has its own strengths and focuses on different aspects of OOP to enhance understanding and application. Explore these methodologies to find the one that resonates most with your learning style:\nBased on games Python Meth 2 Meth 3 "},"title":"Teaching Methodologies"},"/methodologies/javascript-practice/":{"data":{"":"Here you‚Äôll find all OOP-related exercises in Javascript.\nFirst exercise Second exercise Third exercise Fourth exercise Fifth exercise Sixth exercise "},"title":"Javascript practice module"},"/methodologies/javascript-practice/firstjs/":{"data":{"":" üéñÔ∏è Write a JavaScript program to create a class called ‚ÄúPerson‚Äù with properties for name, age and country. Include a method to display the person‚Äôs details. Create two instances of the ‚ÄòPerson‚Äô class and display their details. Plain code approach\nExplanationSolution In the above exercise we create a ‚ÄúPerson‚Äù class with properties for name, age, and country. It includes a method to display the person‚Äôs details.\nFinally it creates two instances of the Person class and displays their details using the displayDetails() method. Solution:\nclass Person { constructor(name, age, country) { this.name = name; this.age = age; this.country = country; } displayDetails() { console.log(`Name: ${this.name}`); console.log(`Age: ${this.age}`); console.log(`Country: ${this.country}`); } } // Create instances of the Person class const person1 = new Person('Francisca Rohan', 25, 'USA'); const person2 = new Person('Raimond Aruna', 30, 'Netherlands'); // Display details of person1 console.log('Person-1 Details:'); person1.displayDetails(); // Display details of person2 console.log('\\nPerson-2 Details:'); person2.displayDetails(); Sample output\n\"Person-1 Details:\" \"Name: Francisca Rohan\" \"Age: 25\" \"Country: USA\" \" Person-2 Details:\" \"Name: Raimond Aruna\" \"Age: 30\" \"Country: Netherlands\" Write your solution below\nSolution in Codepen "},"title":"Exercise 1"},"/methodologies/javascript-practice/secondjs/":{"data":{"":" üéñÔ∏è Write a JavaScript program to create a class called ‚ÄòRectangle‚Äô with properties for width and height. Include two methods to calculate rectangle area and perimeter. Create an instance of the ‚ÄòRectangle‚Äô class and calculate its area and perimeter. ExplanationSolution In the above exercise we create a ‚ÄúPerson‚Äù class with properties for name, age, and country. It includes a method to display the person‚Äôs details.\nFinally it creates two instances of the Person class and displays their details using the displayDetails() method. Solution:\nclass Rectangle { constructor(width, height) { this.width = width; this.height = height; } calculateArea() { return this.width * this.height; } calculatePerimeter() { return 2 * (this.width + this.height); } } // Create an instance of the Rectangle class const rectangle = new Rectangle(12, 10); // Calculate area and perimeter of the rectangle const area = rectangle.calculateArea(); const perimeter = rectangle.calculatePerimeter(); // Display the results console.log(`Rectangle Area: ${area}`); console.log(`Rectangle Perimeter: ${perimeter}`); Sample output\n\"Rectangle Area: 120\" \"Rectangle Perimeter: 44\" Write your solution below\nSolution in Codepen "},"title":"Exercise 2"},"/methodologies/languages/":{"data":{"":"graph TD A[Starting poing] --\u003e X(Learn the OOP basics) X --\u003e B(Choose language and approach) B --\u003e C[Python] B --\u003e D[Java] B --\u003e E[C++] B --\u003e F[JavaScript] F --\u003e G(Processing) F --\u003e H(P5.js) C --\u003e I(Arcade) C --\u003e J(Pygame) ","languages#Languages":"Explore the following sections to start adding more contents:\nJava Python Javascript C++ "},"title":"Language selection"},"/methodologies/languages/cpp/":{"data":{"abstraction#Abstraction":"Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.\nData Abstraction may also be defined as the process of identifying only the required characteristics of an object, ignoring the irrelevant details. The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the object.\n//abstract class abstract class GFG{ //abstract methods declaration abstract void add(); abstract void mul(); abstract void div(); } ","class-and-object#Class and object":" codepublic class GFG { static String Employee_name; static float Employee_salary; static void set(String n, float p) { Employee_name = n; Employee_salary = p; } static void get() { System.out.println(\"Employee name is: \" +Employee_name ); System.out.println(\"Employee CTC is: \" + Employee_salary); } public static void main(String args[]) { GFG.set(\"Rathod Avinash\", 10000.0f); GFG.get(); } } Output Employee name is: Rathod Avinash Employee CTC is: 10000.0 ","encapsulation#Encapsulation":"It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n//Encapsulation using private modifier //Employee class contains private data called employee id and employee name class Employee { private int empid; private String ename; } ","example#Example":" // Java program to Demonstrate Polymorphism // This class will contain // 3 methods with same name, // yet the program will // compile \u0026 run successfully public class Sum { // Overloaded sum(). // This sum takes two int parameters public int sum(int x, int y) { return (x + y); } // Overloaded sum(). // This sum takes three int parameters public int sum(int x, int y, int z) { return (x + y + z); } // Overloaded sum(). // This sum takes two double parameters public double sum(double x, double y) { return (x + y); } // Driver code public static void main(String args[]) { Sum s = new Sum(); System.out.println(s.sum(10, 20)); System.out.println(s.sum(10, 20, 30)); System.out.println(s.sum(10.5, 20.5)); } } Output 30 60 31.0 ","inheritance#Inheritance":"Inheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as ‚Äúis-a‚Äù relationship.\n//base class or parent class or super class class A{ //parent class methods void method1(){} void method2(){} } //derived class or child class or base class class B extends A{ //Inherits parent class methods //child class methods void method3(){} void method4(){} } ","object-oriented-programming-course#Object-oriented programming course":"Object-oriented programming course "},"title":"C++"},"/methodologies/languages/java/":{"data":{"abstraction#Abstraction":"Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.\nData Abstraction may also be defined as the process of identifying only the required characteristics of an object, ignoring the irrelevant details. The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the object.\n//abstract class abstract class GFG{ //abstract methods declaration abstract void add(); abstract void mul(); abstract void div(); } ","class-and-object#Class and object":" codepublic class GFG { static String Employee_name; static float Employee_salary; static void set(String n, float p) { Employee_name = n; Employee_salary = p; } static void get() { System.out.println(\"Employee name is: \" +Employee_name ); System.out.println(\"Employee CTC is: \" + Employee_salary); } public static void main(String args[]) { GFG.set(\"Rathod Avinash\", 10000.0f); GFG.get(); } } Output Employee name is: Rathod Avinash Employee CTC is: 10000.0 ","encapsulation#Encapsulation":"It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n//Encapsulation using private modifier //Employee class contains private data called employee id and employee name class Employee { private int empid; private String ename; } ","example#Example":" // Java program to Demonstrate Polymorphism // This class will contain // 3 methods with same name, // yet the program will // compile \u0026 run successfully public class Sum { // Overloaded sum(). // This sum takes two int parameters public int sum(int x, int y) { return (x + y); } // Overloaded sum(). // This sum takes three int parameters public int sum(int x, int y, int z) { return (x + y + z); } // Overloaded sum(). // This sum takes two double parameters public double sum(double x, double y) { return (x + y); } // Driver code public static void main(String args[]) { Sum s = new Sum(); System.out.println(s.sum(10, 20)); System.out.println(s.sum(10, 20, 30)); System.out.println(s.sum(10.5, 20.5)); } } Output 30 60 31.0 ","inheritance#Inheritance":"Inheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as ‚Äúis-a‚Äù relationship.\n//base class or parent class or super class class A{ //parent class methods void method1(){} void method2(){} } //derived class or child class or base class class B extends A{ //Inherits parent class methods //child class methods void method3(){} void method4(){} } ","object-oriented-programming-course#Object-oriented programming course":"Object-oriented programming course "},"title":"Java"},"/methodologies/languages/javascript/":{"data":{"abstraction#Abstraction":"Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.\nData Abstraction may also be defined as the process of identifying only the required characteristics of an object, ignoring the irrelevant details. The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the object.\n//abstract class abstract class GFG{ //abstract methods declaration abstract void add(); abstract void mul(); abstract void div(); } ","class-and-object#Class and object":" codepublic class GFG { static String Employee_name; static float Employee_salary; static void set(String n, float p) { Employee_name = n; Employee_salary = p; } static void get() { System.out.println(\"Employee name is: \" +Employee_name ); System.out.println(\"Employee CTC is: \" + Employee_salary); } public static void main(String args[]) { GFG.set(\"Rathod Avinash\", 10000.0f); GFG.get(); } } Output Employee name is: Rathod Avinash Employee CTC is: 10000.0 ","encapsulation#Encapsulation":"It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n//Encapsulation using private modifier //Employee class contains private data called employee id and employee name class Employee { private int empid; private String ename; } ","example#Example":" // Java program to Demonstrate Polymorphism // This class will contain // 3 methods with same name, // yet the program will // compile \u0026 run successfully public class Sum { // Overloaded sum(). // This sum takes two int parameters public int sum(int x, int y) { return (x + y); } // Overloaded sum(). // This sum takes three int parameters public int sum(int x, int y, int z) { return (x + y + z); } // Overloaded sum(). // This sum takes two double parameters public double sum(double x, double y) { return (x + y); } // Driver code public static void main(String args[]) { Sum s = new Sum(); System.out.println(s.sum(10, 20)); System.out.println(s.sum(10, 20, 30)); System.out.println(s.sum(10.5, 20.5)); } } Output 30 60 31.0 ","inheritance#Inheritance":"Inheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as ‚Äúis-a‚Äù relationship.\n//base class or parent class or super class class A{ //parent class methods void method1(){} void method2(){} } //derived class or child class or base class class B extends A{ //Inherits parent class methods //child class methods void method3(){} void method4(){} } ","object-oriented-programming-course#Object-oriented programming course":"Object-oriented programming course "},"title":"Javascript"},"/methodologies/languages/python/":{"data":{"abstraction#Abstraction":"Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.\nData Abstraction may also be defined as the process of identifying only the required characteristics of an object, ignoring the irrelevant details. The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the object.\n//abstract class abstract class GFG{ //abstract methods declaration abstract void add(); abstract void mul(); abstract void div(); } ","class-and-object#Class and object":" codepublic class GFG { static String Employee_name; static float Employee_salary; static void set(String n, float p) { Employee_name = n; Employee_salary = p; } static void get() { System.out.println(\"Employee name is: \" +Employee_name ); System.out.println(\"Employee CTC is: \" + Employee_salary); } public static void main(String args[]) { GFG.set(\"Rathod Avinash\", 10000.0f); GFG.get(); } } Output Employee name is: Rathod Avinash Employee CTC is: 10000.0 ","encapsulation#Encapsulation":"It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield.\n//Encapsulation using private modifier //Employee class contains private data called employee id and employee name class Employee { private int empid; private String ename; } ","example#Example":" // Java program to Demonstrate Polymorphism // This class will contain // 3 methods with same name, // yet the program will // compile \u0026 run successfully public class Sum { // Overloaded sum(). // This sum takes two int parameters public int sum(int x, int y) { return (x + y); } // Overloaded sum(). // This sum takes three int parameters public int sum(int x, int y, int z) { return (x + y + z); } // Overloaded sum(). // This sum takes two double parameters public double sum(double x, double y) { return (x + y); } // Driver code public static void main(String args[]) { Sum s = new Sum(); System.out.println(s.sum(10, 20)); System.out.println(s.sum(10, 20, 30)); System.out.println(s.sum(10.5, 20.5)); } } Output 30 60 31.0 ","inheritance#Inheritance":"Inheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as ‚Äúis-a‚Äù relationship.\n//base class or parent class or super class class A{ //parent class methods void method1(){} void method2(){} } //derived class or child class or base class class B extends A{ //Inherits parent class methods //child class methods void method3(){} void method4(){} } ","object-oriented-programming-course#Object-oriented programming course":"Object-oriented programming course "},"title":"Python"},"/methodologies/python-practice/":{"data":{"":"Here you‚Äôll find all OOP-related exercises in Python.\nFirst exercise Second exercise Third exercise Fourth exercise Fifth exercise Sixth exercise "},"title":"Python practice module"},"/methodologies/python-practice/firstpython/":{"data":{"":" üéñÔ∏è Write a Python program to create a class representing a Circle. Include methods to calculate its area and perimeter. Plain code approach\nExplanationSolution In the above exercise we create a ‚ÄúPerson‚Äù class with properties for name, age, and country. It includes a method to display the person‚Äôs details.\nFinally it creates two instances of the Person class and displays their details using the displayDetails() method. Solution:\n# Import the math module to access mathematical functions like pi import math # Define a class called Circle to represent a circle class Circle: # Initialize the Circle object with a given radius def __init__(self, radius): self.radius = radius # Calculate and return the area of the circle using the formula: œÄ * r^2 def calculate_circle_area(self): return math.pi * self.radius**2 # Calculate and return the perimeter (circumference) of the circle using the formula: 2œÄ * r def calculate_circle_perimeter(self): return 2 * math.pi * self.radius # Example usage # Prompt the user to input the radius of the circle and convert it to a floating-point number radius = float(input(\"Input the radius of the circle: \")) # Create a Circle object with the provided radius circle = Circle(radius) # Calculate the area of the circle using the calculate_circle_area method area = circle.calculate_circle_area() # Calculate the perimeter of the circle using the calculate_circle_perimeter method perimeter = circle.calculate_circle_perimeter() # Display the calculated area and perimeter of the circle print(\"Area of the circle:\", area) print(\"Perimeter of the circle:\", perimeter) Sample output\nInput the radius of the circle: 4 Area of the circle: 50.26548245743669 Perimeter of the circle: 25.132741228718345 "},"title":"Exercise 1"},"/methodologies/python-practice/secondpython/":{"data":{"":" üéñÔ∏è Here it goes the second python exercise "},"title":"Exercise 2"},"/tutorial/":{"data":{"":"","bloques-de-c√≥digo#Bloques de c√≥digo":"Para insertar un bloque de c√≥digo se utiliza la siguiente sintaxis usando backticks (`):\n```el lenguaje en el que queremos poner el c√≥digo el c√≥digo que queremos poner ``` por ejemplo, si queremos poner un bloque de c√≥digo en Python, se utiliza:\n```python def say_hello(): print(\"Hello!\") ``` y el resultado ser√° as√≠\ndef say_hello(): print(\"Hello!\") Bloques de c√≥digo con n√∫meros de linea Para insertar un bloque de c√≥digo con n√∫meros de linea se utiliza linenos=table y opcionalmente se pone linenostart=(n√∫mero de l√≠nea) para definir en qu√© n√∫mero de l√≠nea empieza el c√≥digo. Todo esto usando la siguiente sintaxis y usando backticks (`):\n```el lenguaje que queremos poner{linenos=table, linenostart=(n√∫mero de l√≠nea)} el c√≥digo que queremos poner ``` por ejemplo, si queremos poner un bloque de c√≥digo en Python, se utiliza:\n```python{linenos=table, linenostart=18} def say_hello(): print(\"Hello!\") ``` y el resultado ser√° as√≠\n18 19 def say_hello(): print(\"Hello!\") Copiar c√≥digo El bot√≥n de copiado est√° activado por default para cada bloque de c√≥digo.","diagramas#Diagramas":"Para insertar un diagrama se utiliza Mermaid. Mermaid es una herramienta basada en Javascript que permite generar diagramas y diagramas de flujo a partir de texto. Para m√°s informaci√≥n sobre Mermaid, se puede consultar la documentaci√≥n oficial. Se pueden generar todo tipo de diagramas, como diagramas de flujo, diagramas de secuencia, diagramas de clases, diagramas de Gantt, etc. Para insertar un diagrama se utiliza la siguiente sintaxis:\n```mermaid graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ``` y el resultado ser√° as√≠\ngraph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD;Se recomienda el uso de un editor de Mermaid para facilitar la construcci√≥n del diagrama como Mermaid.live","elementos-adicionales#Elementos adicionales":"Callouts Un callout es un elemento que permite resaltar un texto. Para insertar un callout se utiliza la siguiente sintaxis:\nCallout default {{\u003c callout \u003e}} En esta p√°gina se encuentra el tutorial para construir el sitio web de la asignatura de POO. {{\u003c /callout \u003e}} y el resultado ser√° as√≠\nEn esta p√°gina se encuentra el tutorial para construir el sitio web de la asignatura de POO. Callout de informaci√≥n {{\u003c callout type=\"info\" \u003e}} En este callout se encuentra informaci√≥n importante. {{\u003c /callout \u003e}} y el resultado ser√° as√≠\n‚ÑπÔ∏è En este callout se encuentra informaci√≥n importante. Callout de advertencia {{\u003c callout type=\"warning\" \u003e}} Este callout est√° pensado para atraer la atenci√≥n de quien lo lee. {{\u003c /callout \u003e}} y el resultado ser√° as√≠\n‚ö†Ô∏è Este callout est√° pensado para atraer la atenci√≥n de quien lo lee. Callout de error {{\u003c callout type=\"error\" \u003e}} Este callout est√° pensado para indicar que algo ha salido mal. {{\u003c /callout \u003e}} y el resultado ser√° as√≠\nüö´ Este callout est√° pensado para indicar que algo ha salido mal. Botones (cards) Un bot√≥n es un elemento que permite resaltar un enlace. Para insertar un bot√≥n se utiliza la siguiente sintaxis:\n{{\u003c cards \u003e}} {{\u003c card link=\"la ruta del archivo al que se quiere dirigir\" title=\"Nombre bot√≥n\" icon=\"√≠cono\" \u003e}} {{\u003c card link=\"/ruta\" title=\"Siguiente bot√≥n\" \u003e}} {{\u003c /cards \u003e}} Bot√≥n de ejemplo Bot√≥n secundario Los nombres de los √≠conos pueden ser reemplazados por los disponibles en Heroicons","enlaces#Enlaces":"Para insertar un enlace se utiliza la siguiente sintaxis:\n[Texto del enlace](/ruta/al/enlace) por ejemplo, si queremos poner un enlace a la p√°gina principal de la asignatura, se utiliza:\n[Enlace a la p√°gina principal](https://arojaspe.github.io/Hugo-POO-UN/) y el resultado ser√° as√≠\nEnlace a la p√°gina principal","imagenes#Imagenes":"","listas#Listas":"","organizaci√≥n-de-archivos#Organizaci√≥n de archivos":"","tablas#Tablas":"Para insertar una tabla se utiliza la siguiente sintaxis:\n| Columna 1 | Columna 2 | Columna 3 | |-----------|-----------|-----------| | Elemento 1 | Elemento 2 | Elemento 3 | |------------|------------|------------| | Elemento 4 | Elemento 5 | Elemento 6 | y el resultado ser√° as√≠\nColumna 1 Columna 2 Columna 3 Elemento 1 Elemento 2 Elemento 3 ","tutoriales-adicionales#Tutoriales adicionales":" Markdown Guide Markdown Cheatsheet Markdown Tutorial Markdown Reference Hextra guide ","t√≠tulos-y-textos#T√≠tulos y textos":"","videos#Videos":" ‚õ∞Ô∏è En esta p√°gina se encuentra el tutorial para construir el sitio web de la asignatura de POO con todo tipo de contenidos. Organizaci√≥n de archivos Dentro de cada carpeta existe un n√∫mero de archivos y carpetas que se describen a continuaci√≥n:\ncontent _index.md docs _index.md El resto de archivos POO-concepts _index.md El resto de archivos donde estar√°n los conceptos de POO languages _index.md El resto de archivos donde estar√°n los conceptos de POO para cada lenguaje de programaci√≥n about _index.md El resto de archivos con informaci√≥n del curso practice _index.md El resto de archivos donde estar√°n los ejercicios Javascript-practice _index.md El resto de archivos donde estar√°n los ejercicios de Javascript Python-practice _index.md El resto de archivos donde estar√°n los ejercicios de Python hugo.yaml ‚Üí Donde est√° la configuraci√≥n de la p√°gina T√≠tulos y textos Para generar un t√≠tulo se utiliza el s√≠mbolo # seguido del t√≠tulo. El n√∫mero de # indica el nivel de t√≠tulo. Por ejemplo, para generar un t√≠tulo de primer nivel se utiliza # T√≠tulo de primer nivel. Para generar un t√≠tulo de segundo nivel se utiliza ## T√≠tulo de segundo nivel. Y as√≠ sucesivamente.\nEl texto se puede resaltar utilizando el s√≠mbolo *. Por ejemplo, para generar un texto en negrita se utiliza **Texto en negrita**. Para generar un texto en cursiva se utiliza *Texto en cursiva*. Y as√≠ sucesivamente.\nListas Para generar una lista se utiliza el s√≠mbolo - seguido del elemento de la lista. Por ejemplo, para generar una lista con los elementos elemento1, elemento2 y elemento3 se utiliza:\n- elemento1 - elemento2 - elemento3 Si se quiere hacer una lista ordenada secuencialmente, se utiliza el s√≠mbolo 1. seguido del elemento de la lista. Por ejemplo, para generar una lista con los elementos elemento1, elemento2 y elemento3 se utiliza:\n1. elemento1 2. elemento2 3. elemento3 Si se quiere hacer una lista anidada, se utiliza el s√≠mbolo - seguido del elemento de la lista. Por ejemplo, para generar una lista con los elementos elemento1, elemento2 y elemento3 se utiliza:\n- elemento1 - elemento2 - elemento3 Imagenes Para insertar una imagen se utiliza el siguiente c√≥digo:\n![Texto alternativo](/ruta/a/la/imagen) por ejemplo, si queremos poner la imagen de este link https://source.unsplash.com/featured/800x600?landscape, se utiliza:\n![Texto alternativo](https://source.unsplash.com/featured/800x600?landscape) y el resultado ser√° as√≠ Videos Para insertar un video se utiliza el siguiente c√≥digo:\n{{\u003c youtube id_del_video \u003e}} por ejemplo, si queremos poner el video de este link https://www.youtube.com/watch?v=Da-2h2B4faU, se utiliza:\n{{\u003c youtube Da-2h2B4faU \u003e}} y el resultado ser√° as√≠ "},"title":"Tutorial"}}